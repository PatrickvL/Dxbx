<html>

	<HEAD>
		<link rel="stylesheet" type="text/css" href="dxbx.css"/>
		<TITLE>Shadow_tj - DXBX</TITLE>
		<META NAME="description" CONTENT="DXBX - XBOX EMULATION">
		<META NAME="keywords" CONTENT="xbox, xbox emu, xbox emulation, cxbx, dxbx">
		<META NAME="robot" CONTENT="index,follow">
		<META NAME="author" CONTENT="shadowtj@shadowtj.org">
		<META NAME="revisit-after" CONTENT="20">
		<style type="text/css">
.style1 {
	text-align: center;
}
</style>
	</HEAD>

	<BODY>
	

	<p class="style1">
	<img alt="" src="images/dxbxlogo.jpg" width="398" height="77"></p>
	<p class="style1"><span><a href="index.html">News&nbsp;</a>&nbsp;&nbsp;
	<a href="faq.html">Faq</a>&nbsp;&nbsp;&nbsp; <a href="status.html">Status</a>&nbsp;&nbsp;</span>&nbsp; 
	<a href="download.html">Downloads</a>&nbsp;&nbsp;&nbsp; 
	<a href="translationguide.html">Translation guide</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
	<p><span><span lang="en-us"><b>Translation Guide:</b></span></p>
	</span><span lang="en-us">
	<br>
	Because Dxbx is primarily focussed on translating Cxbx to the Delphi 
	Language,<br>
	we need to maintain a proper set of rules. One problem in translating Cxbx 
	is,<br>
	that there are various branches to choose from;<br>
	\Cxbx\Trunk . The main source<br>
	\Cxbx\branches\private\caustik - Caustic&#39;s private work branch<br>
	\Cxbx\branches\private\dstien, Based on martin rev. 39 - Nisse&#39;s work<br>
	\Cxbx\branches\private\martin - Martin&#39;s work<br>
	\Cxbx\branches\private\shogun - blueshogun96&#39;s work<br>
	<br>
	Most of the translation work has used martin&#39;s branch. But now that there<br>
	are more branches to choose from (namely dstien and shogun), we need to mark<br>
	our translations with a header, signifying which branch and revistion where<br>
	used when translating a function. Also, update these headers when another<br>
	revision comes along!<br>
	<br>
	So, add this header line to each function you translate (with applicable 
	details):<br>
	// Branch:martin Revision:39 Translator:PatrickvL<br>
	<br>
	For kernel functions, also specifiy which source was used to determine the<br>
	signature of that function, like this :<br>
	// Source: OpenXdk<br>
	Sources are: Cxbx, OpenXdk, XBMC, ReactOS, APILogger (See below for 
	details).<br>
	<br>
	Calling conventions<br>
	-------------------<br>
	Calling conventions should be translated as follows :<br>
	<br>
	WINAPI and NTAPI -&gt; stdcall (see http://www.nynaeve.net/?p=42)<br>
	__fastcall -&gt; register<br>
	<br>
	<br>
	Adding patches<br>
	--------------<br>
	Every time you want to enable a new patch on some function, do the 
	following:<br>
	<br>
	Determine from which Xbox SDK library the function originates, and arrange 
	for<br>
	pattern (.pat) files for this library, from as much SDK&#39;s as possible.<br>
	<br>
	(If you don&#39;t have any SDK, or don&#39;t know how to create a .pat file,<br>
	contact one of our developers - we might be able to help you out.<br>
	<br>
	Please note, that We can&#39;t give you an SDK or the pattern-generation tools,<br>
	as these are proprietary software!)<br>
	<br>
	With these .pat files, run PatternTrieBuilder.exe to get an updated version<br>
	of the data structure (StoredTrie.dpt) that Dxbx uses to detect functions.<br>
	(When compiling the DxbxKrnl.DLL project, this data is linked into the DLL.)<br>
	So now, when you run your game, you should see your function being detected,<br>
	as mentioned in the log like this : <br>
	<br>
	DxbxHLE : Detected at $00011000 : &#39;SomeFunction&#39;<br>
	<br>
	Now that Dxbx can detect the function, implement your patch (don&#39;t forget to<br>
	declare it with the correct arguments and &quot;stdcall&quot; calling convention).<br>
	<br>
	To register it, scroll down to the &#39;exports&#39; section of the unit where 
	you&#39;re<br>
	implementing the patch (create one if it&#39;s not there yet - look in another<br>
	unit, like uEmuD8D.pas, for an example of how this should look).<br>
	Add a line that reads (replacing both &#39;SomeFunction&#39;s with your patch) :<br>
	<br>
	EmuSomeFunction name PatchPrefix + &#39;SomeFunction&#39;,<br>
	<br>
	If you followed these steps and made no mistakes, DxbxKrnl.DLL will keep<br>
	compiling just fine; But now when running your game, you should see a log<br>
	line mentioning that your patch was applied to some address in the game!<br>
	This goes fully automatic; To verify, check the log for a line like this :<br>
	<br>
	DxbxHLE : Installed patched from $00204080 (SomeFuntion) to $100ABCDE<br>
	<br>
	The addresses will be different, but the name should match your new patch.<br>
	<br>
	<br>
	<br>
	CToPas<br>
	------<br>
	CToPas is a tool that can help you translating C code to Delphi.<br>
	It does this by executing a number of automated replacements, so that C code<br>
	starts to resemble Delphi code. This is no reliable translation however,<br>
	so to get functionally equivalent code, manual changes are also needed.<br>
	<br>
	When using CToPas, be aware of these syntaxis that might need to be 
	reversed:<br>
	&quot; mod &quot; -&gt; &quot;%&quot; (inside strings)<br>
	&quot; not &quot; -&gt; &quot;!&quot; (inside strings)<br>
	<br>
	<br>
	Operators<br>
	---------<br>
	Converting C/C++ operators to Delphi:<br>
	-= operator<br>
	<br>
	var1 -= var2;<br>
	{ this equates to: }<br>
	var1 := var1 - var2;<br>
	<br>
	<br>
	+= operator<br>
	<br>
	var1 += var2;<br>
	{ this equates to: }<br>
	var1 := var1 + var2;<br>
	<br>
	<br>
	&amp;= operator<br>
	<br>
	var1 &amp;= var2;<br>
	{ this equates to: }<br>
	var1 := var1 AND var2;<br>
	<br>
	<br>
	|= operator<br>
	<br>
	var1 |= var2;<br>
	{ this equates to: }<br>
	var1 := var1 OR var2;<br>
	<br>
	<br>
	*= operator <br>
	<br>
	var1 *= var2;<br>
	{ this equates to: }<br>
	var1 := var1 * var2;<br>
	<br>
	<br>
	Pointer translation<br>
	-------------------<br>
	<br>
	C/C++ <br>
	<br>
	*variabele = value;<br>
	PDWord *pSampleValue;<br>
	<br>
	Delphi<br>
	<br>
	variabele^ := value;<br>
	pSampleValue : PDWord;<br>
	<br>
	<br>
	Xbox Kernel sources<br>
	-------------------<br>
	Additional sources that can give you more insight into the Xbox Kernel API&#39;s 
	:<br>
	<br>
	APILogger - APIReporter source :<br>
	http://forums.xbox-scene.com/index.php?showtopic=456303<br>
	<br>
	Cxbx SVN (dstein and shogun&#39;s private branches are the most up to date) :<br>
	http://cxbx.svn.sourceforge.net/viewvc/cxbx/branches/private/dstien/wip/src/<br>
	http://cxbx.svn.sourceforge.net/viewvc/cxbx/branches/private/shogun/wip/src/<br>
	<br>
	JwaNative - Jedi WinAPI project :<br>
	http://blog.delphi-jedi.net/jedi-api-headers/<br>
	<br>
	OpenXDK - Open Source, Free Legal Xbox Development Kit :<br>
	http://sourceforge.net/projects/openxdk/<br>
	<br>
	ReactOS SVN - Open source windows NT clone, see it&#39;s kernel implementation :<br>
	http://svn.reactos.org/svn/reactos/trunk/reactos/ntoskrnl/<br>
	<br>
	XBMC - See the xbox folder, and especially Undocumented.h :<br>
	http://xbmc.org/trac/browser/trunk/XBMC/xbmc/xbox</span>
	

	</BODY>
</html>
